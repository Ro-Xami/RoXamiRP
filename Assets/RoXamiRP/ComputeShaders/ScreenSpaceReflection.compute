#pragma kernel ScreenSpaceReflection

#include "Assets/RoXamiRP/ShaderLibrary/Common.hlsl"
#include "Assets/RoXamiRP/Shaders/Common/CameraDepthAttachment.hlsl"
#include "Assets/RoXamiRP/Shaders/Common/CameraColorAttachment.hlsl"

RWTexture2D<float4> _ScreenSpaceReflectionTexture;
TEXTURE2D(_GBuffer1);
SAMPLER(sampler_GBuffer1);

float4 _texelSize;
float4 _ssrParams;
#define _maxStep _ssrParams.x
#define _stepSize _ssrParams.y
#define _thickness _ssrParams.z

float3 ComputeNormalizedDeviceCoordinatesWithZNoUvStart(float3 position, float4x4 clipSpaceTransform)
{
    float4 positionCS = ComputeClipSpacePosition(position, clipSpaceTransform);

    #if UNITY_UV_STARTS_AT_TOP
    // Our world space, view space, screen space and NDC space are Y-up.
    // Our clip space is flipped upside-down due to poor legacy Unity design.
    // The flip is baked into the projection matrix, so we only have to flip
    // manually when going from CS to NDC and back.
    positionCS.y = -positionCS.y;
    #endif

    positionCS /= positionCS.w;
    positionCS.xy = positionCS.xy * 0.5 + 0.5;

    return positionCS.xyz;
}

float SampleDepth(float2 uv)
{
    return _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, uv, 0).r;
}

float3 SampleNormal(float2 uv)
{
    return normalize(_GBuffer1.SampleLevel(sampler_GBuffer1, uv, 0).rgb);
}

float3 SampleColor(float2 uv)
{
    return _CameraColorTexture.SampleLevel(sampler_CameraColorTexture, uv, 0).rgb;
}

[numthreads(8,8,1)]
void ScreenSpaceReflection(uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)_texelSize.x || id.y > (uint)_texelSize.y)
    {
        return;
    }
    float2 ssrUV = id.xy;
    _ScreenSpaceReflectionTexture[ssrUV] = 0;
    
    float2 screenSpaceUV = float2(ssrUV) * _texelSize.zw;
    float depth = SampleDepth(screenSpaceUV);
    //withoutSkybox
    #if defined(UNITY_REVERSED_Z)
        if (depth <= FLT_MIN)
        {
            return;
        }
    #else
        depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, depth);
        if (depth >= 1)
        {
            return;
        }
    #endif
    
    float3 positionWS = CalculateDepthToPositionWS(depth, screenSpaceUV);
    float3 viewDir = GetViewDirWS(positionWS);
    float3 normalDir = SampleNormal(screenSpaceUV);
    float3 reflectionDir = normalize(reflect(-viewDir, normalDir));

    float3 rayPositionWS = positionWS + normalDir * 0.001f;
    float3 rayMarchStep = reflectionDir * _stepSize;

    UNITY_LOOP
    for (int i = 0; i < _maxStep; i++)
    {
        rayPositionWS += rayMarchStep;
        float3 rayCS = ComputeNormalizedDeviceCoordinatesWithZNoUvStart(rayPositionWS, unity_MatrixVP);
        float rayZ = GetReverseDepth(rayCS.z);
        float2 rayScreenSpaceUV = rayCS.xy;
        if (rayScreenSpaceUV.x > 1 || rayScreenSpaceUV.y > 1 || rayScreenSpaceUV.x < 0 || rayScreenSpaceUV.y < 0)
        {
            break;
        }
        float depthZ = SampleDepth(rayScreenSpaceUV);
        depthZ = GetReverseDepth(depthZ);
        float zDistance = rayZ - depthZ;

        if (zDistance >= 0 && zDistance <= _thickness)
        {
            float3 rayNormalWS = SampleNormal(rayScreenSpaceUV);
            if (dot(reflectionDir, rayNormalWS) > 0)
            {
                break;
            }

            _ScreenSpaceReflectionTexture[ssrUV] = float4(SampleColor(rayScreenSpaceUV), 1);
            break;
        }
    }
}